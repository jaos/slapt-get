Frequently Asked Questions:

*Contents
1.  What is slapt-get ?
2.  Why yet another package management tool for Slackware?
3.  How do I build/install slapt-get?  How do I remove slapt-get?
4.  How do I find a package I want to install?
5.  Can I upgrade all my installed packages?
6.  How can I see what will be upgraded without upgrading?
7.  What if I only want to download the updates?
8.  How can I re-install an existing package?
9.  Can I "dist-upgrade" to a newer Slackware release?
10. What about package dependencies?
11. What about multiple package sources?
12. How can I get more detailed statistics for downloads?
13. How can I install every available package?
14. What if I only want to upgrade one package?
15. What about Dropline support?
16. How can I generate an exclude list for an entire disk set?
17. How do I create my own package source?
18. How can I download every package in a disk set?
19. How can I add dependency information to my packages?
20. How do I get the newest development version of slapt-get?
21. How can I contribute my ideas or code?
22. How can I get slapt-get to speak in my native tongue?
23. How do I set the output language?
24. How do I specify proxy settings?
25. How can I exclude all *pre*, *beta*, and *686* packages safely?
26. How does the transaction engine work?
27. How does the package version comparison algorithm work?
28. I am tracking current, how do I keep the base disk set up to date?
29. How would I script an ldd dependency hack with slapt-get?
30. Does EXCLUDE work for install as well as upgrade and dist-upgrade?
31. What about package conflicts?  How can I specify a conflict for my package?
32. Is the ROOT environment variable honored for install and upgrading?
33. How do I specify the exact version of a package to install?
34. Why is upgradepkg complaining it cannot find installpkg or removepkg, with sudo?
35. How can I specify a username/password for the connection to the package source?
36. /var/cache/slapt-get is growing large, how can I safely free up space?
37. What about extra, testing, or pasture packages?
38. Can I use slapt-get to mirror packages?
39. Is there a way to use tab completion for the package names in Bash?
40. How do I remove obsoleted packages?
41. What provisions have you made for dialup users?
42. Is there a way to get a report with the pending updates emailed to me?
43. What if I don't trust third party sources for upgrades?
44. How do I specify an addon that is not a dependency of my package?
45. Will slapt-get break my system?
46. What is a meta package and how can I take advantage of it?
47. How can I downgrade a package?
48. How can I search the contents of a package for a file or library?
49. Will slapt-get support a --compile like option for slackbuilds?
50. What about mirror fall back / fail-over ?
51. How do I install a kernel rather than upgrade the existing kernel?
52. What are the relationships of CHECKSUMS.md5, PACKAGES.TXT and package_data?
53. Does slapt-get support the GPG/PGP signature verification? 
54. Why am I getting "GPGME: Invalid crypto engine"?
55. How do I support GPG signature verification in my package repository?
56. What does "GPGME: Bad file descriptor, GPG key could not be imported." mean?
57. How do I assign priorities to my package sources?
58. How do I get around "Peer certificate cannot be authenticated with given CA certificates."?



1.  What is slapt-get ?

 slapt-get is an APT like system for Slackware package management. It allows
 one to search slackware.com and mirrors for packages, compare them with
 installed packages, install new packages or upgrade installed packages all
 with a few simple commands. Great for scripting as well.

 slapt-get is not affiliated or endorsed by Patrick Volkerding / slackware.com.


2.  Why yet another package management tool for Slackware?

 Various reasons came together which inspired me to create slapt-get.  I was
 trying to explain to a good friend of mine the functionality provided by
 apt-get on Debian GNU/Linux.  And I needed a uniform and easily scripted 
 method of installing software on various User-Mode Linux instances I was
 using for development.  Thus slapt-get was born.


3.  How do I build/install slapt-get?  How do I remove slapt-get?

 Two ways to install:

  A: You can build slapt-get from source and use the 'install' make target,
 
  B: You can build from source and make a Slackware package with the 'pkg'
     make target.  Then install the generated package within the newly created
     'pkg' directory.

 If you installed via `make install`, there is an 'uninstall' make target.

 If you installed the slack package, then use removepkg.

 See the INSTALL file included with slapt-get.


4.  How do I find a package I want to install?

 You can use the --search feature, supplying an expression.  POSIX 
 and extended regular expressions are supported.  This searches the name,
 version, location, or description of packages.


5.  Can I upgrade all my installed packages?

 Yes, use the --upgrade option.  slapt-get will check for newer versions of all
 packages already installed.

 Please review the Slackware ChangeLog.txt for the Slackware release you are
 running.  This is especially important for -current.


6.  How can I see what will be upgraded without upgrading?

 If the transaction report is not enough, use the --simulate option before
 --upgrade.  See slapt-get --help


7.  What if I only want to download the updates?

 Use the --download-only option with --upgrade.
 See slapt-get --help


8.  How can I re-install an existing package?

 Use the --reinstall option with --install pkg_name.
 See slapt-get --help


9.  Can I "dist-upgrade" to a newer Slackware release?

 Yes. See also http://slackwiki.org/Upgrade_Using_Slapt-get.

 Change your source location within /etc/slapt-get/slapt-getrc to point to
 the newer release directory.  --update your local package cache, then
 --dist-upgrade to the newer release.  You will also want to disable any
 third party package sources while upgrading to a newer release due to the fact
 that third party packages might not be as rigorously tested as official
 packages, or may cause conflicts with files provided by official packages.

 For instance, you have the following line as your source:

   SOURCE=ftp://distro.ibiblio.org/pub/Linux/distributions/slackware/slackware-9.0/

 Simply change the URL to point to current, like so:

   SOURCE=ftp://distro.ibiblio.org/pub/Linux/distributions/slackware/slackware-current/

 CAVEAT: Follow the instructions in UPGRADE.TXT.

 Now you --dist-upgrade to retrieve the package data for that release.
 What dist-upgrade does is basically make sure that any missing packages
 from the base disk set are installed, as well as upgrade to any newer
 versions of the currently installed packages.  All of this happens in
 one transaction.

 dist-upgrade'ing involves doing the following:

   ### upgrade your local package cache
   $ slapt-get --update

   ### first, download all of the packages prior to upgrading
   $ slapt-get --dist-upgrade --download-only

   ### second, install (not upgrade!) the newest kernel
   $ slapt-get --install kernel --no-upgrade

   ### then, upgrade the most important
   #(this installs any newer versions)
   $ slapt-get --install glibc-solibs pkgtools sed

 In newer versions of slapt-get, dist-upgrade automatically handles
 installing/upgrading glibc-solibs, pkgtools, and sed prior to any
 other changes.

   ### finally, let slapt-get upgrade the rest
   $ slapt-get --dist-upgrade

  You can specify --remove-obsolete to remove all depreciated packages.
  CAUTION: this can only take into consideration packages that are available
  from your current sources.  Thus self made packages will be considered
  obsolete as well (they can be excluded within slapt-getrc, however).  Only
  use this if you have been using Slackware packages exclusively.  You can
  also use this option for information purposes, observing the obsolete
  packages, then passing all the ones you are sure of to --remove (which can
  accept multiple packages at once).
   ### dist upgrade and remove all depreciated/obsolete packages
   $ slapt-get --dist-upgrade --remove-obsolete

 Then follow the rest of the directions in UPGRADE.TXT.

 You should make sure any new packages within the disk sets you are using are
 also installed, as they will not be detected during --dist-upgrade, as only 
 packages already installed will be upgraded.  To accomplish this, you can
 specify slapt-get to install a disk set like so:

   ### install all X and X application packages
   $ slapt-get --install-set x xap

 Do the same for all your installed disk sets, such as gnome, x, xap, l, n, etc.

 Piotr Simon has a script that easily identifies new packages from release
 release.  You can find it here:
 http://www.tenboard.com/slackware/index.php?path=SlackBuilds/



10.  What about package dependencies?

 First of all, slapt-get does not provide dependency resolution for vanilla
 Slackware packages (ie, official Slackware packages that come with the
 distribution).

 However, slapt-get does provide a framework for dependency resolution for
 packages that follow the Slackware package format, while still being backwards
 compatible.  This information is stored in so called meta files within the
 package.  slapt-get does not parse the packages themselves.  It uses the 
 PACKAGES.TXT package database that Patrick Volkerding provides along with his
 packages.  slapt-get uses this file by extending it with optional extra fields.
 This information is stored within the package simply as a means of easy
 transport, to later be parsed into a PACKAGES.TXT.  For example, the entry
 for man within PACKAGES.TXT looks like:

   PACKAGE NAME:  man-1.5l-i386-1.tgz
   PACKAGE LOCATION:  ./slackware/ap
   PACKAGE SIZE (compressed):  166 K
   PACKAGE SIZE (uncompressed):  390 K
   PACKAGE DESCRIPTION:
   man: man (format and display the on-line manual pages)

 It is extended like so:

   PACKAGE NAME:  man-1.5l-i386-1.tgz
   PACKAGE MIRROR:  http://www.slackware.at/data/slackware-9.1/
   PACKAGE LOCATION:  ./slackware/ap
   PACKAGE SIZE (compressed):  166 K
   PACKAGE SIZE (uncompressed):  390 K
   PACKAGE REQUIRED: groff >= 1.56-noarch-1,man-pages | man-pages-de
   PACKAGE CONFLICTS:  
   PACKAGE SUGGESTS:  
   PACKAGE DESCRIPTION:
   man: man (format and display the on-line manual pages)

 The REQUIRED line is an addition supported by slapt-get, along with CONFLICTS
 and SUGGESTS.  The meta files supporting dependencies, conflicts, and
 suggestions are within the packages inside the ./install/ directory.  The
 REQUIRED information is stored in the slack-required file.  The CONFLICTS
 information is stored within the slack-conflicts file.  The SUGGESTS
 information is stored in the slack-suggests file.  See FAQ #19 for a breakdown
 of the structure of REQUIRED, FAQ #31 for CONFLICTS, and FAQ #44 for SUGGESTS.
 MIRROR is an optional location so that the packages can be hosted elsewhere
 (this is the internal representation slapt-get uses after caching the package
 date from the remote package source).

 This information is added to the PACKAGES.TXT file within the package repository
 by the provider of the packages.

 The inclusion of this information within the Slackware package format does not
 inhibit the ability for Slackware pkgtools to install these packages.  This
 information is silently ignored and discarded after the package is installed.


11. What about multiple package sources?

 You can use multiple package sources with slapt-get.

 See the example slapt-getrc in the source tarball or look in the
 slapt-get directory within /usr/doc/ if you installed a binary package.
 See the README for further details.


12. How can I get more detailed statistics for downloads?

 If you would like more notification on downloading pkgs/files, use the 
 command line option --show-stats (or -S).  This will show curl style
 download information.


13. How can I install every available package?

 Even though it is not built in, it is simple since slapt-get is easy to script
 with.  Here is how to install every package that is available but not
 currently installed:

   slapt-get --available|grep inst=no|awk '{print $1}'|uniq|xargs -r slapt-get --install


14. What if I only want to upgrade one package?

 The --install option works for this as well.  If the package is already
 installed, it will check and install any newer versions:

 slapt-get --install {pkg_name}


15. What about Dropline support?

 There is no direct support for Dropline packages.  If you do not want them
 upgraded, put either the package names or a regex into the exception list.

 Use the following to exclude Dropline (from the example slapt-getrc):
 
  EXCLUDE=kernel-ide,kernel-source,kernel-headers,kernel-modules,lilo,.*-[0-9]+dl$,devs


16. How can I generate an exclude list for an entire disk set?

 You can exclude an entire disk set by placing the disk set as an exclude.  Be
 sure to use the beginning-of-line (^) and end-of-line ($) operators for
 specific matching.  For example:

  To exclude all of ./slackware/x and ./slackware/xap
  EXCLUDE=^./slackware/x$,^./slackware/xap$


17. How do I create my own package source?

 Within slapt-getrc, change your SOURCE= lines to point to your package
 source.  This might be a local source using file:// URLs, or a publicly
 available source.

 For example, you could have an official and a local source like:
 SOURCE=ftp://ftp.slackware.no/pub/linux/slackware/slackware-9.1/
 SOURCE=file:///usr/src/local_pkg_repository/

 This local directory must have the PACKAGES.TXT and CHECKSUMS.md5 files
 present.  This could be a mounted Slackware release CDROM, or a custom
 repository.

 The CHECKSUMS.md5 file can be generated with find:
  rm CHECKSUMS.md5; find . -name '*.tgz' -exec md5sum {} >> CHECKSUMS.MD5 \;

 The PACKAGES.TXT can be generated by the following script:

 ### BEGIN SCRIPT
    #!/bin/sh
    #DL_URL=http://your_remove_pkg_host.tld/packages/
    # This program is free software; you can redistribute it and/or modify
    # it under the terms of the GNU General Public License as published by
    # the Free Software Foundation; either version 2 of the License, or
    # any later version.

    function gen_packages_txt {
	    echo '' > PACKAGES.TXT
	    find . -type f -name '*.meta' -exec cat {} \; >> PACKAGES.TXT
      cat PACKAGES.TXT | gzip -9 -c - > PACKAGES.TXT.gz
    }

    function gen_md5_checksums {
	    echo '' > CHECKSUMS.md5
	    find . -type f -regextype posix-egrep -regex '.*\.[tgblzikx]+$' -exec md5sum {} \; >> CHECKSUMS.md5
      cat CHECKSUMS.md5 | gzip -9 -c - > CHECKSUMS.md5.gz
    }

    function gen_meta {
	    if [ ! -f $1 ]; then
		    echo "File not found: $1"
		    exit 1;
	    fi
			if [ "`echo $1|grep -E '(.*{1,})\-(.*[\.\-].*[\.\-].*).[tgblzikx]{2,}[ ]{0,}$'`" == "" ]; then
				return;
			fi

      PKGEXT=${1##*.}
      case $PKGEXT in
        tgz) DECOMPRESS=gzip ;;
        tbz) DECOMPRESS=bzip2 ;;
        tlz) DECOMPRESS=lzma ;;
        txz) DECOMPRESS=xz ;;
      esac

	    NAME=$(echo $1|sed -re "s/(.*\/)(.*.$PKGEXT)$/\2/")
	    LOCATION=$(echo $1|sed -re "s/(.*)\/(.*.$PKGEXT)$/\1/")
	    SIZE=$(du -bk $1 | awk '{print $1}')
	    USIZE=$(expr $(cat $1 | $DECOMPRESS -dc | wc -c) / 1024)
	    REQUIRED=$($DECOMPRESS -dc $1 | tar -xO install/slack-required 2>/dev/null|xargs -r -iZ echo -n "Z,"|sed -e "s/,$//")
	    CONFLICTS=$($DECOMPRESS -dc $1 | tar -xO install/slack-conflicts 2>/dev/null|xargs -r -iZ echo -n "Z,"|sed -e "s/,$//")
	    SUGGESTS=$($DECOMPRESS -dc $1 | tar -xO install/slack-suggests 2>/dev/null|xargs -r )
	    METAFILE=${NAME%$PKGEXT}meta
	    echo "PACKAGE NAME:  $NAME" > $LOCATION/$METAFILE
	    if [ -n "$DL_URL" ]; then
	    	echo "PACKAGE MIRROR:  $DL_URL" >> $LOCATION/$METAFILE
	    fi
	    echo "PACKAGE LOCATION:  $LOCATION" >> $LOCATION/$METAFILE
	    echo "PACKAGE SIZE (compressed):  $SIZE K" >> $LOCATION/$METAFILE
	    echo "PACKAGE SIZE (uncompressed):  $USIZE K" >> $LOCATION/$METAFILE
	    echo "PACKAGE REQUIRED:  $REQUIRED" >> $LOCATION/$METAFILE
	    echo "PACKAGE CONFLICTS:  $CONFLICTS" >> $LOCATION/$METAFILE
	    echo "PACKAGE SUGGESTS:  $SUGGESTS" >> $LOCATION/$METAFILE
	    echo "PACKAGE DESCRIPTION:" >> $LOCATION/$METAFILE
	    $DECOMPRESS -dc $1 | tar -xO install/slack-desc |grep -E '\w+\:'|grep -v '^#' >> $LOCATION/$METAFILE
	    echo "" >> $LOCATION/$METAFILE
    }

    case "$1" in
	    pkg)
		    if [ -n "$2" ]; then
			    gen_meta $2
		    else
			    echo "$0 [pkg [file]|all|new|PACKAGESTXT|MD5]"
		    fi
	    ;;
	    all)
		    for pkg in `find . -type f -regex '.*\.[tgblzikx]+$' -print`
		    do
			    gen_meta $pkg
		    done
		    $0 PACKAGESTXT
		    $0 MD5
	    ;;
	    new)
		    for pkg in `find . -type f -regex '.*\.[tgblzikx]+$' -print`
		    do
			    if [ ! -f ${pkg%${pkg##*.}}meta ]; then
				    gen_meta $pkg
			    fi
		    done
	    ;;
	    PACKAGESTXT)
		    gen_packages_txt
	    ;;
	    MD5)
		    gen_md5_checksums
	    ;;
	    *)
		    echo "$0 [pkg [file]|all|new|PACKAGESTXT|MD5]"
	    ;;
    esac
 ### END SCRIPT


18. How can I download every package in a disk set?

 You can use the install-set option to install all of the packages within a
 disk set.

 To install every package from xap:

   slapt-get --install-set xap

 Disk set names are not hardcoded.  slapt-get performs a search for any
 packages with a location of /{disk_set_arg}$.  So custom repositories
 with directory structures of ./foo, ./bar, and ./baz can use "foo", "bar", and
 "baz" as --install-set options.


19. How can I add dependency information to my packages?

 This is for package developers.  If you are not a package developer, please
 request your packager include this information.

 To export the dependency data for a package, include within your package the
 following file:

   ./install/slack-required

 The structure of this file is one entry per line in the following format:

    package_name

 or
    [package_name] [condition] [version]

 where [condition] is

    =, >=, =<, <, or >

 <= and =< should both work, just in case of editing errors.

 Version should include the arch and build if using '='.  That is the full
 Slackware package version designation.  1.1.0-386-1 is valid.  1.1.0 is not.

 You can specify multiple packages to satisfy a dependency.  The alternate
 packages are separated by a pipe, |.

    jre = 1.4.1-i586-1 | j2sdk >= 1.4.2-i386-1 | jdk > 1.5.0-i386-1

 The package names are case sensitive.  So make sure you keep the case of the
 package name as it appears in the package filename.

 An example slack-required file is present within the slapt-get slack package.

 This data will then need to be extracted when the mirrors PACKAGES.TXT file
 is generated.  See FAQ #17 for an example of how to generate the
 PACKAGES.TXT file.  The following is an example entry:

    PACKAGE NAME:  man-pages-1.56-noarch-1.tgz
    ...(snip)
    PACKAGE REQUIRED:  man >= 1.5l-i386-1

 An example command to pull that data:
   tar xzfO pkg-name-version-arch-rel.tgz install/slack-required |xargs -iZ echo -n "Z,"|sed -e "s/,$//"


20. How do I get the newest development version of slapt-get?

 See the 'Using git' section of the INSTALL document.


21. How can I contribute my ideas or code?

 The easiest is either Github:
 https://github.com/jaos/slapt-get/issues

 Or https://software.jaos.org/git/slapt-get
 for manual patches/etc.


22. How can I get slapt-get to speak in my native tongue?

 GNU gettext is used to extract all translatable strings from the source.
 Please look in the po/ directory of the slapt-get source.  Copy the
 slapt-get.pot file to a new file named with your native language abbreviation,
 ending in .po.  For example, to translate to German, download the current
 translation file available here:
 http://software.jaos.org/BUILD/slapt-get/po/slapt-get.pot

 $ cp slapt-get.pot de.po

 Edit that file.  For every msgid, translate that into the msgstr "".  Leave the
 formatting the same.

 See also https://www.transifex.com/jaos/slapt-get/


23. How do I set the output language?

 You can change the locale at runtime by setting the LANG environment
 variable.

 $ LANG=fr slapt-get


24. How do I specify proxy settings?

 slapt-get takes advantage of the normal http_proxy and ftp_proxy shell
 variables. Here are some examples:

  # setting the env variables for the entire session
  $ export http_proxy=http://host:port
  $ export ftp_proxy=ftp://host:port
  # just setting them for the current command invocation
  $ http_proxy=http://host:port slapt-get --update

 If you are using ~/.netrc, libcurl automatically picks up your preferences.
 See the netrc(5) manpage for more information.


25. How can I exclude all *pre*, *beta*, and *686* packages safely?

 An exclude regex like .*pre.* , .*beta.*, or .*686.* may net you the results
 of excluding all packages with those characters in the name or version.  But
 they may also catch packages that have those characters normally occurring in
 the package name.

 This regex seems to work much better:

   [0-9\_\.\-]{1}pre[0-9\-\.\-]{1}

 for beta packages:

   [0-9\_\.\-]{1}beta[0-9\-\.\-]{1}

 or for i686 packages (or for i585 or i486):

   [0-9\_\.\-]+i686

 Anything matching these regex will be added to the exclude list for the
 transaction.


26. How does the transaction engine work?

 The last few series of releases (0.9.6x and 0.9.7x) have supported
 transactions so that nothing happens unless everything checks out properly.
 The transaction is built up of packages to install, upgrade and remove. The
 transaction status will be reported to the user to be confirmed (unless the
 user passes in --no-prompt on the command line).  After this confirmation, all
 packages will be downloaded before anything else happens.  If anything fails
 to download, the transaction is immediately aborted.	If all packages download
 successfully, all removals in the transaction are completed first (in case 
 packages being installed/upgraded share files with the packages to be removed).
 Next, all packages to be installed (new installs) are installed.  This should
 satisfy dependencies of the packages to be upgraded, which follow after the new
 installs.  The order of package dependencies, where available, is honored. 
 These dependencies are installed prior to the packages that require them. 
 This helps keep your system in a consistent state.


27. How does the package version comparison algorithm work?

 Say we have foo-1.1.3-i386-1rob and foo-1.1.3-i686-1.

 The version parts will be compared, first 1, then 1, then 3.  At this point,
 both packages are equal, since 1.1.3 == 1.1.3. If one is greater at this
 point, the version check returns.

 Then, it checks to make sure that both pkgs have the same number of "version
 parts".  This is the case in this example, both have 3 (1,1,3).	This is useful
 when you see packages like 1.2 and 1.2.1. Whichever has more parts wins.  At
 this point, we know if one only has 2 parts, and the other has 3, then the
 first two parts of both version strings have to be equal.

 Then, the package versions are checked to see if they follow the Slackware
 convention.  This is determined by checking the first instance of '-' against
 the last instance.  If the pointer returned from index and rindex are
 different, then we assume we have at least two package version separators
 (meaning we should have an upstream version, arch, and build at least).

 If two separators are found, the build portion of the string is located.  The
 integer value of the build strings are compared.  So "1rob" has an integer
 value of 1, and "1" has an integer value of 1.  So in our example, both package
 versions are the same.

 If the only difference is the arch and the packages follow the conventions,
 then they should always be equal.

 If two separators are not found, then the entire version string from both pkgs
 are compared via strcmp.  This is a fallback mechanism.


28. I am tracking current, how do I keep the base disk set up to date?

 If you are tracking current, --dist-upgrade is more appropriate than
 --upgrade.

 Even if you aren't intentionally switching to a newer distribution,
 --dist-upgrade will ensure that the base set is always present while at the
 same time keeping your installed packages up to date.  See also FAQ #9.

 --dist-upgrade --reinstall can also be useful when some packages in the base
 disk set change versions (cxxlibs and sed come to mind).  This will reinstall
 those base packages that may have lesser version numbers.

 --dist-upgrade --remove-obsolete will remove any packages that Pat has removed
 from current.  CAUTION: this can only take into consideration packages that
 are available from your current sources.  Thus self made packages will be
 considered obsolete as well (they can be excluded within slapt-getrc, however).
 Only use this if you have been using Slackware packages exclusively.  You can
 also use this option for information purposes.

 --dist-upgrade --remove-obsolete --reinstall will do all of the above in one
 action.  It will ensure every package from /a/ is reinstalled, and remove
 obsolete packages.


29. How would I script an ldd dependency hack with slapt-get?

 Do something like the following:

 ### begin script
 #!/bin/sh
 # slapt-get wrapper to hack dependencies via ldd where slack-required isn't available
 # Copyright (C) 11-30-2003 Jason Woodward <woodwardj at jaos dot org>
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # any later version.
 WORKINGDIR=`grep WORKINGDIR /etc/slapt-get/slapt-getrc|cut -f2 -d'='`
 MF=MANIFEST
 PKGLINES=${WORKINGDIR}/depslapt_pkgs
 DEPDATA=()
 DEPDATACOUNT=0
 
 function get_pkg_cache_data {
 	if [ -f ${MF} ]; then rm ${MF};fi
 	for url in `grep '^SOURCE' /etc/slapt-get/slapt-getrc|cut -f2 -d'='`
 	do
 		echo "retrieving data from $url"
 		if [ -f ${MF}.bz2 ]; then rm ${MF}.bz2;fi
 		wget -q ${url}/${MF}.bz2
 		if [ -f ${MF}.bz2 ]; then
 			bunzip2 -c ${MF}.bz2 >> ${MF}; rm ${MF}.bz2
 		else
 			wget -q ${url}/slackware/${MF}.bz2
 			if [ -f ${MF}.bz2 ]; then bunzip2 -c ${MF}.bz2 >> ${MF}; rm ${MF}.bz2; fi
 		fi
 	done
	if [ ! -f ${MF} ]; then echo "Failed to download MANIFEST"; exit 1; fi
 	echo "extracting package data"
 	grep -n ' Package\: ' ${MF}|awk '{print $1 $3}'|sed -re "s/\|//g" > ${PKGLINES}
 }
 
 function map_to_pkg {
 	LOOKUP=$1
 	LASTPKG=
 	for pkgline in `cat ${PKGLINES}|cut -f1 -d':'`
 	do
 		if [ $LOOKUP -gt $pkgline ]; then
 			false
 		else
 			LASTPKG=`grep -B 1 $pkgline ${PKGLINES} |head -1|cut -f2 -d':'`
 			return
 		fi
 	done
 	### clear it in case we get here
 	LASTPKG=
 }
 
 function lookup_lib {
 	for linenumber in `grep -n $1 $WORKINGDIR/slapt-get/${MF}|cut -f1 -d':'`
 	do
 		map_to_pkg $linenumber
 		if [ -n "$LASTPKG" ]; then
 			DEPS[$DEPCOUNT]=`basename $LASTPKG|sed -re "s/(.*{1,})\\-(.*[\\.\\-].*[\\.\\-].*).tgz[ ]{0,}$/\1/"`
 			DEPCOUNT=$((DEPCOUNT + 1))
 		fi
 	done
 }
 
 function resolve_dependencies {
 	DEPS=()
 	DEPCOUNT=0
 	for pkg in "$@"
 	do
 		INST=`ls /var/log/packages/|grep ${pkg}|sort -rn|head -1`
    FILES="`cat /var/log/packages/$INST|grep 'bin\/\|lib\/lib.*\.so'|grep -v '\/$'`"
 		for file in $FILES
 		do
 			MISSINGLIBS=`ldd /${file}|grep -i 'not found'|awk '{print $1}'|sort|uniq`
 			for lib in $MISSINGLIBS
 			do
 				echo "Missing lib: $lib"
 				lookup_lib $lib
 			done
 		done
 	done
 	### recurse
 	if [ $DEPCOUNT -gt 0 ]; then
 		slapt-get --install ${DEPS[*]} || exit
 		resolve_dependencies ${DEPS[*]}
 	fi
 }
 
 # give usage if no arguments
 if [ -z "$1" ]; then echo "Usage: $0 [--update|packages]"; exit; fi
 # get package cache data if it is not already there, or we want it
 cd ${WORKINGDIR}
 if [ "$1" == "--update" ]; then get_pkg_cache_data; exit; fi
 if [ ! -f ${PKGLINES} ]; then get_pkg_cache_data; fi
 # read pkg data into memory 
 while read line;do DEPDATA[${DEPDATACOUNT}]=$line; DEPDATACOUNT=$((DEPDATACOUNT + 1)); done < ${PKGLINES}
 # install with slapt-get, then call the resolve_dependencies
 slapt-get $SLAPT_OPTS --install "$@" || exit
 resolve_dependencies $@
 ### end script


30. Does EXCLUDE work for install as well as upgrade and dist-upgrade?

 No, EXCLUDE is only consulted for install-set, upgrading, and dist-upgrading. 
 If you specify the package name as an argument to --install, slapt-get will 
 ignore the EXCLUDE list.

 This does not apply to dependencies.  If a dependency of a specified package
 is detected, it is checked against the EXCLUDE list.  If excluded, the 
 dependency check for the specified package fails.  Override this with
 --ignore-dep (to ignore dependency failures).


31. What about package conflicts?  How can I specify a conflict for my package?

 Package conflicts are not as common as dependencies, but just as crucial.
 Packages such as lprng and cups sometimes duplicate the same functionality and 
 must not be installed side by side.

 To address this, include within your package ./install/slack-conflicts.  This
 file has the same syntax as the slack-required file, just without the version
 information.

 The following is a fictitious example of a lprng slack-conflicts file:

 # cat ./install/slack-conflicts
   gnome-cups-manager
   libgnomecups
   cups
 #

 In this example, we want to specify that the gnome-cups-manager, cups, and
 libgnomecups packages are in direct conflict with lprng.

 Conflicts will exclude a package during --upgrade or --dist-upgrade.  If the
 package specified to install is conflicted, the user is prompted to remove
 the conflict and install the requested package.


32. Is the ROOT environment variable honored for install and upgrading?

 Yes, if you have been using ROOT with installpkg and upgradepkg, slapt-get
 will modify where it looks for the package logs based on this environment
 variable.

 For example export ROOT=/home/keary/newroot would make slapt-get look in
 /home/keary/newroot/var/log/packages for installed package information and
 install all upgraded/new packages in /home/keary/newroot instead of /

 All calls to installpkg, removepkg, and upgradepkg will be passed along this
 environment variable.  See the installpkg(8) manpage.

 NOTE: Be sure to run ldconfig -r $ROOT to ensure appropriate library links are
 built.


33. How do I specify the exact version of a package to install?

 Specify the version along with the package name with the --install argument.

 For example, to install pkgtools version 9.0.0-i386-1, use 'pkgtools-9.0.0-i386-1'
 as the --install argument.


34. Why is upgradepkg complaining it cannot find installpkg or removepkg, with sudo?

 Right from the sudo man pages Security Notes section:

  "Note, however, that the actual PATH environment variable is not modified and
   is passed unchanged to the program that sudo executes."

 Make sure you include /sbin in your shells PATH environment variable before using
 slapt-get via sudo.  Or use su - -c 'slapt-get [options] [arg]s'.


35. How can I specify a username/password for the connection to the package source?

 This can be specified right in the package source URL within the
 /etc/slapt-get/slapt-getrc.  You will want to make sure that sensitive
 passwords are protected, and possibly harden the permissions on
 /etc/slapt-get/slapt-getrc so that only the root user can read the file.

 Examples:

  SOURCE=http://user:pass@host.org/path/to/packages/
  SOURCE=ftp://user:pass@host.org/pub/packages/


36. /var/cache/slapt-get is growing large, how can I safely free up space?

 Use the --clean option to remove all the cached packages from the tree within
 /var/cache/slapt-get.

 Or use --autoclean, which is like clean but clears out the local repository of
 retrieved package files that can no longer be downloaded, and are largely
 useless. This allows a cache to be maintained over a long period without 
 it growing out of control.


37. What about extra, testing, or pasture packages?

 Example source entries for the extra, testing, and pasture packages sets can be
 found within the example.slapt-getrc file under /usr/doc/slapt-get*/.


38. Can I use slapt-get to mirror packages?

 Yes, you can use it to mirror packages by using the following:

  slapt-get --available|awk '{print $1}'|xargs -r slapt-get --download-only \
		--reinstall --install

 The packages will then be mirrored under ${ROOT}/var/cache/slapt-get in the
 directory structure they where found in.  You can then generate the 
 PACKAGES.TXT and CHECKSUMS.md5 files using the script in FAQ #17 which would
 allow you to use this mirror as a slapt-get source.

 Optionally, you can set this directory as your WORKINGDIR in order to
 avoid copying the package files.


39. Is there a way to use tab completion for the package names in Bash?

 Yes, this completion was contributed by Alec Thomas.

 This goes in your ~/.bashrc file (or in /etc/bash_completion,
 /etc/bash_completion.d/, /etc/profile, or /etc/profile.d/):

  complete_slaptget()
  {
	  cur=${COMP_WORDS[COMP_CWORD]}
	  if [ "${COMP_WORDS[$[$COMP_CWORD-1]]}" = "--remove" ]; then
		  COMPREPLY=( $( cd /var/log/packages; ls "$cur"* 2> /dev/null | sed -e 's/-[^-]*-[^-]*-[^-]*$//') )
	  else
		  COMPREPLY=( $( slapt-get --search "^$cur" 2> /dev/null | awk '{print $1}' ) )
	  fi
  }
  complete -F complete_slaptget -o default slapt-get


40. How do I remove obsoleted packages?

 If you are tracking current or are dist-upgrading to a new release, you will
 encounter packages that you have installed that are no longer required or
 part of the basic Slackware install.  If you only have the official Slackware
 package sources in your slapt-getrc file, then you can do the following:

  # slapt-get --remove --remove-obsolete

 NOTE: You will want to exclude any packages that are self made so they are
       not removed.


41. What provisions have you made for dialup users?

 The following measurements to save bandwidth have been taken:

  * Incomplete package downloads will resume from where they left off.
  * ability to set --retry option to specify the number of times to retry
    failed downloads.
  * The package data download (via --update) will only download those sources
    that have changed since the last download, and supports compressed copies
    of the data files (PACKAGES.TXT.gz and CHECKSUMS.md5.gz).
  * The transaction report gives accurate statistics about sizes required to
    download, as well as how much additional space will be required after
    unpacking the package archives.  This report will also indicate how
    much is left to resume if the download was previously interrupted.


42. Is there a way to get a report with the pending updates emailed to me?

 Yes, you may use these scripts to send notification via email any time updates
 are available:

 http://www.nerdworks.org/download/scripts/update-notifier/
 http://www.aetherstorm.com/slapt_update


43. What if I don't trust third party sources for upgrades?

 You can use different slapt-getrc files.  For example:

  slapt-get --config /etc/slapt-get/slapt-getrc.official --update && \
  slapt-get --dist-upgrade

 You will have to run --update every time you change your config file if the
 WORKINGDIR option is the same between configuration files.  Also, if your
 excludes and working directory are different in each file, you will want to
 specify --config with each invocation of slapt-get to ensure that file is
 parsed.


44. How do I specify an addon that is not a dependency of my package?

 You can include a slack-suggests file within your packages ./install/ directory.
 The format of this file follows the slack-required, except version information
 is to be left out.  This version information is useless as you are just making
 a suggestion, not a requirement.  If there is a required version of a package
 you can either specify it within ./install/slack-required or include it within
 the documentation inside of your package.

 The suggestion information is presented during the transaction report or via the
 --show pkg-name query.


45. Will slapt-get break my system?

 slapt-get is a frontend to pkgtools.  As such you have the same ability to
 break a working system using slapt-get as you do using upgradepkg without
 caution.  A few points are in order:

 * slapt-get will not make assumptions or do things without you telling it to,
   ie: installing, removing, or upgrading packages
 * untested updates are risky, whether using official packages or third party
   packages.
 * slapt-get will not change your system such that you can only use slapt-get
   or are somehow locked into using slapt-get.  The only additions to your
   system are /etc/slapt-get and /var/cache/slapt-get.  You are free to try another
   solution or go back to manual upgradepkg.
 * UPGRADE.TXT and ChangeLog.txt are still required reading for upgrades or
   running -current.


46. What is a meta package and how can I take advantage of it?

 A meta package is a package that only contains its dependencies in the
 slack-required file.  There is nothing in the package to install, it just
 provides a name and a dependency list.  A good example would be GNOME.  If a
 "gnome" meta package existed that required the gtk libraries and gnome
 applications, your user could install the gnome meta package without having to
 know all of the packages that go along with it.  This is a good application of
 dependencies and suggestions.

 When rolling out a new version of your application suite (gnome in our example),
 you can increment the version of the meta package and change the included packages
 and their required versions.  That way you can roll out a 2.x release update, but
 provide an easy way to roll back to a previous 1.x release of the entire application
 suite.


47. How can I downgrade a package?

 You can downgrade a package by specifying the version of the package when using
 --install.  You will also need to provide --reinstall.  For example:

  # slapt-get --search rsync
  rsync-2.5.6-i386-1 [inst=no]: rsync
  rsync-2.6.2-i386-1 [inst=yes]: rsync

  # slapt-get --install rsync-2.5.6-i386-1 --reinstall
  Reading Package Lists... Done
  The following packages will be upgraded:
    rsync
  1 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
  Need to get 121K of archives.
  After unpacking 30K disk space will be freed.
  Do you want to continue? [y/N]


48. How can I search the contents of a package for a file or library?

 slapt-get does not pay attention to the contents of packages.  Slackware
 provides the MANIFEST.bz2 and the contents of /var/log/packages for such
 functionality.  Searching for which installed package owns a file is
 accomplished the easiest by using grep with the contents of
 /var/log/packages/.

 The same can be done with the MANIFEST.bz2 file.  You can use one of the 
 following solutions:

 Put something like this in your shells rc file (or /etc/profile) would do
 just as well:

  # begin
  function search_manifest {
    LASTPKG=

    if [ -z "$1" ]; then return;fi

    if [ -z "$MANIFEST" ]; then
  	  echo "Please set MANIFEST env variable to point to a downloaded MANIFEST.bz2"
  	  return
    fi

    if [ ! -f ${MANIFEST/MANIFEST.bz2/package_list} ]; then
  	  bzgrep -n ' Package\: ' ${MANIFEST}|awk '{print $1 $3}'|sed -re "s/\|//g" >
      ${MANIFEST/MANIFEST.bz2/package_list}
    fi

    FILE=$( echo $1 | sed -re "s/^\///");
    LOOKUP=$(bzgrep -n $FILE $MANIFEST|cut -f1 -d':')

    if [ -z "$LOOKUP" ]; then
  	  echo "$1 not found in $MANIFEST"
  	  return
    fi

     for pkgline in `cat ${MANIFEST/MANIFEST.bz2/package_list}|cut -f1 -d':'`
     do

   	  if [ $LOOKUP -gt $pkgline ]; then
   		  false
   	  else
   		  LASTPKG=`grep -B 1 $pkgline ${MANIFEST/MANIFEST.bz2/package_list}|head -1 \
  				|cut -f2 -d':'|cut -f3 -d'/'`
  		  echo $LASTPKG $1
   		  return
   	  fi

     done
  }
  #end

  Then you'd just call from your shell search_manifest /usr/lib/libpci.a:
  pciutils-2.1.11-i486-5.tgz /usr/lib/libpci.a

 Or you can use this solution provided by Nathan Morell <frizop at eatel.net>:

  #!/usr/bin/perl
  use strict;
  use warnings;
  use PerlIO::gzip;

  open FOO, "<:gzip", "/home/jidar/MANIFEST.gz" or die $!;

  my $temp;
  while (<FOO>){ # And it will be uncompressed...
      if ($_ =~ m/\|\|   Package:  /g) {
          $_ =~ s/\|\|   Package:  /PACKAGE: /g;
          $temp = $_;
      }
      if ($_ =~ m/($ARGV[0])/g) {
          print $temp . $_;
      }
  }


49. Will slapt-get support a --compile like option for slackbuilds?

 No, this is handled by slapt-src.


50. What about mirror fall back / fail-over ?

 This functionality is not built into slapt-get.  Adding multiple sources to
 the same package source at different mirror locations does not buy you auto-
 matic fail-over.  It will provide you with duplicate package listings.

 Instead, you can specify an alternate config file and fall back on it in the
 event your default or original configuration contains sources that are not
 available.  For example:

   slapt-get --update || slapt-get --config /etc/slapt-get/alternaterc --update

 This will allow you to check backup package sources in the event your primary
 are not available.


51. How do I install a kernel rather than upgrade the existing kernel?

 When you run --upgrade or --install kernel-ide, slapt-get attempts to install
 the newest version of kernel-ide (in this example) and upgrade the existing
 version.  To override this, use --install kernel-ide --no-upgrade.


52. What are the relationships of CHECKSUMS.md5, PACKAGES.TXT and package_data?

 The CHECKSUMS.md5 and PACKAGES.TXT come from the remote package sources.  The
 contents of these files are merged into a modified PACKAGES.TXT format that
 represents the packages from all current package sources.

 The merging of all package source information happens during the --update 
 phase.  Each package source is checked in turn.  Every package in the
 PACKAGES.TXT files is matched with the corresponding entry in the CHECKSUMS.md5
 of the package source.  The package data, md5sum, and package source url is
 committed to a running package list.  This list is committed to the 
 package_data file within the working directory (as configured in slapt-getrc).
 package_data represents the aggregate package listing from all current package
 sources. 

 In the event that a package cannot be matched by name and location to the entry
 within the PACKAGES.TXT, the package entry within package_data is left with an
 empty md5sum.

 If the CHECKSUMS.md5 and PACKAGES.TXT files are not successfully retreived,
 the running package list is not committed to package_data.  The previous
 contents of package_data are preserved.  slapt-get immediately aborts with an
 error in this case.  Gslapt, however, prompts to temporarily disable the
 source and continue.


53. Does slapt-get support the GPG/PGP signature verification? 

 Yes, as of 0.9.12 slapt-get can be built with gpgme support that allows 
 slapt-get to verify the signature of the CHECKSUMS file on each mirror.  
 This requires the presence of the signature file and the GPG-KEY file on
 the package source.  The GPG-KEY is imported into the local keychain using
 the --add-keys option.  When running --update, the signature file for the
 CHECKSUMS listing is downloaded and verification is attempted.  If the key
 is not present slapt-get mentions this and continues on.  slapt-get only halts
 if verification failed.


54. Why am I getting "GPGME: Invalid crypto engine"?

 Recent versions of slapt-get support GPG key verification via the GPGME
 library.  GPGME requires gnupg to support the OpenPGP protocol.

 Make sure gnupg and gnupg2 are both installed.


55. How do I support GPG signature verification in my package repository?

 Simply add your GPG key as GPG-KEY in the same directory as your PACKAGES.TXT
 and CHECKSUMS.md5 files.  This is created with the following command template:

  gpg --export --armor your_key_id > GPG-KEY

 CHECKSUMS.md5.asc (or optionally CHECKSUMS.md5.gz.asc) are downloaded along
 with the checksums file.  If the signature is verified, the package source is
 downloaded.  The signature file is generated with the following command template:

  gpg -bas CHECKSUMS.md5


56. What does "GPGME: Bad file descriptor, GPG key could not be imported." mean?

 Make sure the /proc file system is mounted.


57. How do I assign priorities to my package sources?

 The source priority feature is intended for keeping installed packages closely
 synchronized with a trusted repository, rather than upgrading based on package
 version numbers.  This can be useful for tracking the patches which are
 applied to official Slackware releases, or for following Slackware-current,
 where package version numbers are occasionally regressed due to stability
 issues or for other reasons.  Another use for this feature is where the user
 maintains a local repository of customized packages which are to be used in
 preference to those on the public mirrors.

 Each SOURCE can be a assigned a priority level, by appending :{PRIORITY} to
 the source URI.  For example:

  SOURCE={url}:DEFAULT    is the default, lowest priority
  SOURCE={url}:OFFICIAL   assigns more weight, used to denote official sources
  SOURCE={url}:PREFERRED  assigns even more weight to this source
  SOURCE={url}:CUSTOM     highest priority, for your custom package source

 PRIORITY of DEFAULT gives the usual slapt-get behavior, whereby packages are
 upgraded based on their version numbers.  A package from a source with the
 default priority will upgrade the installed package only if the package from
 the source has a higher version number.  This is effectively never used but is
 included for completeness.

 The priorities of OFFICIAL, PREFERRED, and CUSTOM allow the packages from a
 mirror to be tracked more closely.  A package from a source with a priority
 higher than DEFAULT will "upgrade" the installed package whenever the version
 strings differ, regardless of whether this is an upgrade or a downgrade in
 terms of version number comparison.  Where a package is available in different
 versions from several different sources, the package from the source with the
 greatest priority will be used for upgrade.  Version numbers are only
 considered in the event of a tie between two packages from sources with the
 same priority.

 Packages within the patches sub directory always have a slightly increased
 priority of those within the rest of the package source.  This is particularly
 useful for tracking official Slackware patches.  So any packages in /patches
 are assigned +1 priority to the package sources priority.

 The example slapt-getrc in the source tarball or in the slapt-get directory
 within /usr/doc/ provides example usage of package source priority assignment.

 If you do not care for the priority assignment, you can remove the priority 
 attributes from your sources (if present, or never add them if not).

58. How do I get around "Peer certificate cannot be authenticated with given CA certificates."?

 Self signed certificates that cannot be verified cause libcurl to fail the connection.

 To disable this, set the SLAPT_NO_SSL_VERIFYPEER environment variable.

 See also http://curl.haxx.se/libcurl/c/CURLOPT_SSL_VERIFYPEER.html


